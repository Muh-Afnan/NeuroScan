import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from PIL import Image, ImageTk
import cv2
import numpy as np
from Implementation.preprocessing_logic import normalize_image, reduce_noise, skull_strip, remove_artifacts
import os

class PreprocessingFrame(tk.Frame):
    def __init__(self, master,show_train_frame):
        pass
#         super().__init__(master)
#         self.master = master
#         self.show_train_frame = show_train_frame

#         self.grid_rowconfigure(0, weight=1)
#         self.grid_columnconfigure(0, weight=8)
#         self.grid_columnconfigure(1, weight=2)

#         self.left_frame = tk.Frame(self)
#         self.left_frame.grid(row=0, column=0, padx=10, pady=10, sticky='nswe')
#         self.left_frame.grid_rowconfigure(0, weight=1)
#         self.left_frame.grid_columnconfigure(0, weight=1)

#         # Create a canvas and scrollbar for scrolling through thumbnails
#         self.canvas = tk.Canvas(self.left_frame)
#         self.scrollbar = ttk.Scrollbar(self.left_frame, orient="vertical", command=self.canvas.yview)
#         self.scrollable_frame = tk.Frame(self.canvas)

#         # Bind the scrollable frame to the canvas for scrolling
#         self.scrollable_frame.bind(
#             "<Configure>",
#             lambda e: self.canvas.configure(
#                 scrollregion=self.canvas.bbox("all")
#             )
#         )

#         # Create a window on the canvas to hold the scrollable frame
#         self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
#         self.canvas.configure(yscrollcommand=self.scrollbar.set)

#         # Pack the canvas and scrollbar into the left frame
#         self.canvas.pack(side="left", fill="both", expand=True)
#         self.scrollbar.pack(side="right", fill="y")

#         # Create a frame on the right side for control buttons and settings
#         preprocess_menu = tk.Frame(self)
#         preprocess_menu.grid(row=0, column=1, padx=15, pady=15, sticky='nswe')

#         # Configure rows and columns in the right frame
#         preprocess_menu.grid_rowconfigure(0, weight=1)
#         for i in range(17):
#             preprocess_menu.grid_rowconfigure(i, weight=1)
#         preprocess_menu.grid_columnconfigure(0, weight=1)

#         # You should configure it directly without redefining it
#         self.configure_right_frame()
#         self.load_dataset()

        
        # Button to apply normalization to the current image

    def load_dataset(self):
        if not self.master.dataset_path:
            messagebox.showwarning("No Dataset", "Please upload a dataset first.")
            return
        
        preprocess_window = tk.Toplevel(self)
        preprocess_window.title("Data Preprocessing")
        preprocess_window.geometry("1200x800")
        self.build_preprocessing_screen(preprocess_window)

    def build_preprocessing_screen(self, preprocess_window):
        # Image preview frame
        preview_frame = tk.Frame(preprocess_window)
        preview_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Canvas and Scrollbar for image grid
        canvas = tk.Canvas(preview_frame)
        scrollbar = tk.Scrollbar(preview_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas)

        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        # Checkboxes and image preview
        check_vars = []


        def update_grid():
            for widget in scrollable_frame.winfo_children():
                widget.destroy()

            max_width = 150
            max_height = 150
            cols = 4
            rows = (len(self.master.loaded_images) + cols - 1) // cols

            for i in range(rows):
                for j in range(cols):
                    idx = i * cols + j
                    if idx < len(self.master.loaded_images):
                        name, img = self.master.loaded_images[idx]

                        # Resize image for preview
                        img_preview = img.resize((max_width, max_height))
                        img_preview_tk = ImageTk.PhotoImage(img_preview)

                        # Create frame for image and checkbox
                        frame = tk.Frame(scrollable_frame, borderwidth=2, relief="solid")
                        frame.grid(row=i, column=j, padx=5, pady=5)

                        def on_image_click(event, idx=idx):
                            var, _ = check_vars[idx]
                            var.set(not var.get())
                            # event.widget.config(bg="lightblue" if var.get() else "white")

                        img_label = tk.Label(frame, image=img_preview_tk, bg="white")
                        img_label.pack(padx=5, pady=5)
                        img_label.bind("<Button-1>", on_image_click)
                        
                        # Add checkbox for image selection
                        var = tk.BooleanVar()
                        check_vars.append((var, idx))
                        checkbox = tk.Checkbutton(frame, variable=var)
                        checkbox.pack(side=tk.BOTTOM)

                        # Store image reference to prevent garbage collection
                        frame.image = img_preview_tk
            

        update_grid()

        def check_all():
            for aa in check_vars:
                var, _ = aa
                var.set(True)

        def uncheck_all():
            for aa in check_vars:
                var, _ = aa
                var.set(False)
        
            if self.image_paths:
                self.current_image_index = 0
                self.display_thumbnails()  # Show image thumbnails in the left frame
                self.load_image(self.image_paths[self.current_image_index])  # Load the first image
            else:
                messagebox.showwarning("No Images Found", "No images found in the selected directory.")

        preprocess_menu = tk.Frame(preprocess_window)
        preprocess_menu.pack(side=tk.RIGHT, fill=tk.Y, padx=10, pady=10)


        selectall_button = tk.Button(preprocess_menu, text="Select All", command=check_all)
        selectall_button.pack(pady=5)

        unselectall_button = tk.Button(preprocess_menu, text="Un Select All", command=uncheck_all)
        unselectall_button.pack(pady=5)
        self.norm_button = tk.Button(preprocess_menu, text="Normalize Image", command=self.apply_normalization)
        self.norm_button.grid(row=3, column=0, padx = 20,pady=10, sticky='ew')

        # Controls for noise reduction
        self.noise_label = tk.Label(preprocess_menu, text="Noise Reduction:")
        self.noise_label.grid(row=4, column=0, padx = 20,pady=5, sticky='w')
        self.noise_var = tk.StringVar(value='gaussian')  # Default noise reduction method
        self.noise_gaussian = tk.Radiobutton(preprocess_menu, text="Gaussian", variable=self.noise_var, value='gaussian')
        self.noise_median = tk.Radiobutton(preprocess_menu, text="Median", variable=self.noise_var, value='median')
        self.noise_gaussian.grid(row=5, column=0, padx=20, sticky="w")
        self.noise_median.grid(row=5, column=1,sticky="w")

        # Slider to select kernel size for noise reduction
        self.kernel_size_label = tk.Label(preprocess_menu, text="Kernel Size:")
        self.kernel_size_label.grid(row=7, column=0, padx = 20,pady=5, sticky='w')
        self.kernel_size_slider = tk.Scale(preprocess_menu, from_=1, to=15, orient=tk.HORIZONTAL)
        self.kernel_size_slider.set(5)  # Default kernel size
        self.kernel_size_slider.grid(row=8, column=0, padx = 20,pady=5, sticky='ew')

        # Button to apply noise reduction
        self.noise_button = tk.Button(preprocess_menu, text="Apply Noise Reduction", command=self.apply_noise_reduction)
        self.noise_button.grid(row=9, column=0, padx = 20,pady=10, sticky='ew')

        # Controls for skull stripping
        self.skull_label = tk.Label(preprocess_menu, text="Skull Stripping Threshold:")
        self.skull_label.grid(row=10, column=0, padx = 20,pady=5, sticky='w')
        self.skull_threshold_slider = tk.Scale(preprocess_menu, from_=0, to=255, orient=tk.HORIZONTAL)
        self.skull_threshold_slider.set(10)  # Default threshold
        self.skull_threshold_slider.grid(row=11, column=0, padx = 20,pady=5, sticky='ew')

        # Button to apply skull stripping
        self.skull_button = tk.Button(preprocess_menu, text="Apply Skull Stripping", command=self.apply_skull_stripping)
        self.skull_button.grid(row=12, column=0, padx = 20,pady=10, sticky='ew')

        # Controls for artifact removal
        self.artifact_label = tk.Label(preprocess_menu, text="Artifact Removal:")
        self.artifact_label.grid(row=13, column=0, padx = 20,pady=5, sticky='w')
        self.artifact_var = tk.StringVar(value='default')  # Default artifact removal method
        self.artifact_default = tk.Radiobutton(preprocess_menu, text="Default", variable=self.artifact_var, value='default')
        self.artifact_custom = tk.Radiobutton(preprocess_menu, text="Custom", variable=self.artifact_var, value='custom')
        self.artifact_default.grid(row=14, column=0, padx=20,sticky='w')
        self.artifact_custom.grid(row=14, column=1, sticky='w')

        # Button to apply artifact removal
        self.artifact_button = tk.Button(preprocess_menu, text="Remove Artifacts", command=self.apply_artifact_removal)
        self.artifact_button.grid(row=16, column=0, padx = 20,pady=10, sticky='ew')

        # Progress bar to show ongoing processes
        self.progress_bar = ttk.Progressbar(preprocess_menu, orient="horizontal", mode="indeterminate")
        self.progress_bar.grid(row=17, column=0, padx = 20,pady=10, sticky='ew')

    # def display_thumbnails(self):
    #     # Clears existing thumbnails from the scrollable frame
    #     for widget in self.scrollable_frame.winfo_children():
    #         widget.destroy()

    #     self.thumbnails = []  # Reset thumbnails list
    #     for idx, image_path in enumerate(self.image_paths):
    #         image = cv2.imread(image_path)  # Read image file
    #         image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB format
    #         image_pil = Image.fromarray(image_rgb)  # Convert to PIL image
    #         image_pil.thumbnail((100, 100))  # Resize for thumbnails
    #         image_tk = ImageTk.PhotoImage(image_pil)  # Convert to Tkinter image format
    #         self.thumbnails.append(image_tk)

    #         # Create a button with the thumbnail image
    #         button = tk.Button(self.scrollable_frame, image=image_tk, command=lambda idx=idx: self.load_image(self.image_paths[idx]))
    #         button.grid(row=idx // 4, column=idx % 4, padx=5, pady=5)  # Arrange thumbnails in a grid

    # def load_image(self, image_path):
    #     # Load and display the selected image
    #     self.current_image = cv2.imread(image_path)
    #     # self.display_image(self.current_image)  # Display the image in the right frame
    

    # def display_image(self, image):
    #     # Display the current image in the scrollable frame
    #     if image is None:
    #         return
        
    #     image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB format
    #     image_pil = Image.fromarray(image_rgb)  # Convert to PIL image
    #     image_pil.thumbnail((100, 100))  # Resize for thumbnails
    #     image_tk = ImageTk.PhotoImage(image_pil)  # Convert to Tkinter image format

    #             # Check if thumbnail already exists
    #     if 0 <= self.current_image_index < len(self.thumbnails):
    #         # Replace existing thumbnail with updated image
    #         self.thumbnails[self.current_image_index] = image_tk
    #         # Update or add a new button for the thumbnail
    #         button = tk.Button(self.scrollable_frame, image=image_tk, command=lambda idx=self.current_image_index: self.load_image(self.image_paths[idx]))
    #         button.grid(row=self.current_image_index // 4, column=self.current_image_index % 4, padx=5, pady=5)
    #     else:
    #         # Create a new button with the thumbnail image
    #         button = tk.Button(self.scrollable_frame, image=image_tk, command=lambda idx=self.current_image_index: self.load_image(self.image_paths[idx]))
    #         button.grid(row=len(self.thumbnails) // 4, column=len(self.thumbnails) % 4, padx=5, pady=5)
    #         self.thumbnails.append(image_tk)

    def apply_normalization(self):
        # Apply normalization to the current image and update the display
        if self.current_image is not None:
            self.progress_bar.start()  # Start the progress bar animation
            self.update_idletasks()  # Update the GUI to show progress bar
            # Normalize the image and convert it back to 8-bit format
            norm_image = normalize_image(self.current_image)
            norm_image = (norm_image * 255).astype(np.uint8)
            self.display_image(norm_image)  # Display the normalized image
            self.progress_bar.stop()  # Stop the progress bar animation
            messagebox.showinfo("Success", "Normalization applied successfully!")
        else:
            messagebox.showerror("Error", "No image loaded!")

    def apply_noise_reduction(self):
        # Apply noise reduction to the current image and update the display
        if self.current_image is not None:
            self.progress_bar.start()  # Start the progress bar animation
            self.update_idletasks()  # Update the GUI to show progress bar
            method = self.noise_var.get()  # Get the selected noise reduction method
            kernel_size = self.kernel_size_slider.get()  # Get the selected kernel size
            if kernel_size % 2 == 0:
                kernel_size += 1  # Ensure kernel size is odd for Gaussian and median blur
            noise_reduced_image = reduce_noise(self.current_image, method, kernel_size)
            self.display_image(noise_reduced_image)  # Display the noise-reduced image
            self.progress_bar.stop()  # Stop the progress bar animation
            messagebox.showinfo("Success", "Noise reduction applied successfully!")
        else:
            messagebox.showerror("Error", "No image loaded!")

    def apply_skull_stripping(self):
        # Apply skull stripping to the current image and update the display
        if self.current_image is not None:
            self.progress_bar.start()  # Start the progress bar animation
            self.update_idletasks()  # Update the GUI to show progress bar
            threshold = self.skull_threshold_slider.get()  # Get the selected threshold value
            skull_stripped_image = skull_strip(self.current_image, threshold)
            self.display_image(skull_stripped_image)  # Display the skull-stripped image
            self.progress_bar.stop()  # Stop the progress bar animation
            messagebox.showinfo("Success", "Skull stripping applied successfully!")
        else:
            messagebox.showerror("Error", "No image loaded!")

    def apply_artifact_removal(self):
        # Apply artifact removal to the current image and update the display
        if self.current_image is not None:
            self.progress_bar.start()  # Start the progress bar animation
            self.update_idletasks()  # Update the GUI to show progress bar
            method = self.artifact_var.get()  # Get the selected artifact removal method
            artifact_removed_image = remove_artifacts(self.current_image, method)
            self.display_image(artifact_removed_image)  # Display the artifact-removed image
            self.progress_bar.stop()  # Stop the progress bar animation
            messagebox.showinfo("Success", "Artifact removal applied successfully!")
        else:
            messagebox.showerror("Error", "No image loaded!")

# Old Preprocessing Copied File
#  # Copied This Code Open
    # def preprocess_data(self):
    #     if not self.master.dataset_path:
    #         messagebox.showwarning("No Dataset", "Please upload a dataset first.")
    #         return

    #     progress_window = tk.Toplevel(self)
    #     progress_window.title("Preprocessing Progress")
    #     progress_window.geometry("600x400")

    #     tk.Label(progress_window, text="Preprocessing images...").pack(pady=10)

    #     # Create a frame to hold the progress bars and labels
    #     progress_frame = tk.Frame(progress_window)
    #     progress_frame.pack(pady=10)

    #     progress_bars = {}
    #     for step in self.preprocessing_status:
    #         tk.Label(progress_frame, text=step).pack(anchor="w", padx=10)
    #         progress_bar = ttk.Progressbar(progress_frame, orient="horizontal", length=500, mode="determinate")
    #         progress_bar.pack(pady=5)
    #         progress_bars[step] = progress_bar

    #     def run_preprocessing():
    #         total_images = len(self.master.loaded_images)
    #         for step in self.preprocessing_status:
    #             self.preprocessing_status[step].set(True)
    #             progress_bars[step]["maximum"] = total_images
    #             progress_bars[step]["value"] = 0
    #             progress_window.update_idletasks()

    #             # Simulate the preprocessing step
    #             for idx, (name, img) in enumerate(self.master.loaded_images):
    #                 if step == "Normalization":
    #                     img = backend.preprocess_image(img)
    #                 # Update progress bar for the current step
    #                 progress_bars[step]["value"] += 1
    #                 progress_window.update_idletasks()

    #             # Mark the step as complete
    #             self.preprocessing_status[step].set(False)

    #         messagebox.showinfo("Preprocessing", "Preprocessing completed!")
    #         progress_window.destroy()

    #     threading.Thread(target=run_preprocessing).start()

    #  # Copied This Code Close


import tkinter as tk
from tkinter import messagebox, ttk
from PIL import ImageTk
import threading
from Implementation.backend import augment_image

class AugmentFrame(tk.Frame):
    def __init__(self, master, loaded_images):
        super().__init__(master)
        self.master = master
        self.loaded_images = loaded_images
        self.pack(fill=tk.BOTH, expand=True)
        self.build_augmentation_interface()

    def build_augmentation_interface(self):
        # Image preview frame
        preview_frame = tk.Frame(self)
        preview_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Canvas and Scrollbar for image grid
        canvas = tk.Canvas(preview_frame)
        scrollbar = tk.Scrollbar(preview_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas)

        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        # Checkboxes and image preview
        self.check_vars = []
        self.update_grid(scrollable_frame)

        # Augmentation menu
        augmentation_menu = tk.Frame(self)
        augmentation_menu.pack(side=tk.RIGHT, fill=tk.Y, padx=10, pady=10)

        selectall_button = tk.Button(augmentation_menu, text="Select All", command=self.check_all)
        selectall_button.pack(pady=5)

        unselectall_button = tk.Button(augmentation_menu, text="Unselect All", command=self.uncheck_all)
        unselectall_button.pack(pady=5)

        self.create_augmentation_controls(augmentation_menu)

    def update_grid(self, scrollable_frame):
        for widget in scrollable_frame.winfo_children():
            widget.destroy()

        max_width = 150
        max_height = 150
        cols = 4
        rows = (len(self.loaded_images) + cols - 1) // cols

        for i in range(rows):
            for j in range(cols):
                idx = i * cols + j
                if idx < len(self.loaded_images):
                    name, img = self.loaded_images[idx]

                    img_preview = img.resize((max_width, max_height))
                    img_preview_tk = ImageTk.PhotoImage(img_preview)

                    frame = tk.Frame(scrollable_frame, borderwidth=2, relief="solid")
                    frame.grid(row=i, column=j, padx=5, pady=5)

                    img_label = tk.Label(frame, image=img_preview_tk, bg="white")
                    img_label.pack(padx=5, pady=5)
                    img_label.bind("<Button-1>", lambda event, idx=idx: self.on_image_click(event, idx))
                    
                    var = tk.BooleanVar()
                    self.check_vars.append((var, idx))
                    checkbox = tk.Checkbutton(frame, variable=var)
                    checkbox.pack(side=tk.BOTTOM)

                    frame.image = img_preview_tk

    def on_image_click(self, event, idx):
        var, _ = self.check_vars[idx]
        var.set(not var.get())

    def check_all(self):
        for var, _ in self.check_vars:
            var.set(True)

    def uncheck_all(self):
        for var, _ in self.check_vars:
            var.set(False)

    def create_augmentation_controls(self, augmentation_menu):
        rotation_label = tk.Label(augmentation_menu, text="Rotation Angle:")
        rotation_label.pack(pady=5)
        
        rotation_entry = tk.Entry(augmentation_menu)
        rotation_entry.pack(pady=5)
        
        rotation_button = tk.Button(augmentation_menu, text="Apply Rotation", command=lambda: self.apply_rotation(rotation_entry))
        rotation_button.pack(pady=5)

        # Presets for rotation
        presets_frame = tk.Frame(augmentation_menu)
        presets_frame.pack(pady=10)

        for angle in [90, 180, 270]:
            tk.Button(presets_frame, text=f"{angle} Degrees", command=lambda angle=angle: self.apply_preset_rotation(angle)).pack(side=tk.LEFT, padx=5)

        flip_horizontal_var = tk.BooleanVar()
        flip_vertical_var = tk.BooleanVar()
        noise_var = tk.BooleanVar()

        tk.Checkbutton(augmentation_menu, text="Flip Horizontally", variable=flip_horizontal_var).pack(anchor="w", padx=10)
        tk.Checkbutton(augmentation_menu, text="Flip Vertically", variable=flip_vertical_var).pack(anchor="w", padx=10)
        tk.Checkbutton(augmentation_menu, text="Add Noise", variable=noise_var).pack(anchor="w", padx=10)

        noise_value_label = tk.Label(augmentation_menu, text="Noise Value:")
        noise_value_label.pack(pady=5)

        noise_value_entry = tk.Entry(augmentation_menu)
        noise_value_entry.pack(pady=5)

        augment_button = tk.Button(augmentation_menu, text="Apply Augmentations", command=lambda: self.apply_augmentations(flip_horizontal_var, flip_vertical_var, noise_var, noise_value_entry))
        augment_button.pack(pady=10)

    def apply_rotation(self, rotation_entry):
        angle = rotation_entry.get()
        try:
            angle = float(angle)
        except ValueError:
            messagebox.showwarning("Invalid Input", "Please enter a valid rotation angle.")
            return

        for var, idx in self.check_vars:
            if var.get():
                name, img = self.loaded_images[idx]
                rotated_img = augment_image(img, "rotate", angle)
                self.loaded_images[idx] = (name, rotated_img)

        self.update_grid(self.master.children['!frame'])
        messagebox.showinfo("Augmentation Applied", f"Applied {angle} degrees rotation to selected images.")

    def apply_preset_rotation(self, angle):
        self.apply_rotation(lambda: angle)

    def apply_augmentations(self, flip_horizontal_var, flip_vertical_var, noise_var, noise_value_entry):
        selected_images = [idx for var, idx in self.check_vars if var.get()]

        if not selected_images:
            messagebox.showwarning("No Images Selected", "Please select images to augment.")
            return

        for idx in selected_images:
            name, img = self.loaded_images[idx]
            if flip_horizontal_var.get():
                img = augment_image(img, "flip_horizontal")
            if flip_vertical_var.get():
                img = augment_image(img, "flip_vertical")
            if noise_var.get():
                try:
                    noise_value = float(noise_value_entry.get())
                    img = augment_image(img, "add_noise", noise_value)
                except ValueError:
                    messagebox.showwarning("Invalid Input", "Please enter a valid noise value.")
                    return

            self.loaded_images[idx] = (name, img)

        self.update_grid(self.master.children['!frame'])
        messagebox.showinfo("Augmentation Applied", "Selected augmentations applied successfully.")
